# Kickstart library tutorial

Kickstart is intended to ease the way for beginners in C++, and helps to shorten example code for those who help others on the net.

## 1. Installation & compiler requirements.

All you need to do is download, copy and rename, so that the compiler finds the `<kickstart/`&hellip;`>` headers. There is no need to compile the library on its own. All the library code is in headers that you just `#include`.

Installation is described in more detail in [a separate document](../../source/examples/hello-world.md).

Then after installation, to use Kickstart you need to use a compiler option that specifies at least ***C++17***. Also, the Kickstart i/o functionality requires that C++ strings are UTF-8 encoded, which theyâ€™re not by default with the 2019 version of Microsoftâ€™s Visual C++ compiler, and the Kickstart code uses the alternate keywords `and`, `or` and `not`, which again are a problem with Visual C++. Recommended options to guide the compilers:

| *Compiler:* | *Recommended core options:* |
|:-|:-|
| g++ &amp; clang | `-std=c++17` `-pedantic-errors` `-Wall` |
| Visual C++ | `/nologo` `/utf-8` `/EHsc` `/GR` `/permissive-` `/FI"iso646.h"` `/std:c++17` `/Zc:__cplusplus` `/W4` `/wd4459` `/D` `_CRT_SECURE_NO_WARNINGS` `/D` `_STL_SECURE_NO_WARNINGS` |

Happily, for Visual C++ options can be specified in environment variable `CL`, which is used automatically.

## 2. â€œHello, world!â€ â€” or, keep that console window open, please.

Hereâ€™s the classic â€œHello, world!â€ program expressed with Kickstart console output:

*File ([hello-world.cpp](examples/hello-world.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    out << "Hello, world!" << endl;
}
~~~

`out`, `<<` and `endl` are names provided by the Kickstart library in namespace `kickstart::all`. When the output goes to a Windows console then itâ€™s sent there via the UTF-16 based Windows API function `WriteConsoleW` so that e.g. non-English letters are treated correctly. In all other cases the `out` output is delegated to Câ€™s `fwrite`.

However, conversion to text of non-textual arguments is handled by passing them to a `std::ostringstream`. That means that C++ iostreams can be be involved and contribute to an unreasonably large executable size, just as with use of `std::cout` output. A future goal is to remove that and *all* dependencies on iostreams so that the size of a C++ â€œHello, world!â€ executable built by a beginner, can be much less unreasonable.

Result in an ordinary Windows console window:

> C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl hello-world.cpp /Fe"hello"***  
> hello-world.cpp
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***hello***  
> Hello, world!

Works! ğŸ˜ƒ

The **`cl`** command invokes the Visual C++ 2019 compiler, and option `/Fe"hello"` tells it to produce an executable named `hello.exe`, which can then be invoked with command `hello`.

---

Beginners that are learning in Windows, typically insert a â€œstop hereâ€ statement at the end of each program. This keeps the Windows console window open when the program has finished so that the programâ€™s output can be viewed. The stopping statement can be a portable input statement, or it can be e.g. a Windows-specific `system("pause")`, but anyway itâ€™s problematic in several ways:

* Itâ€™s *unreliable*: in a typical beginner's program the input buffer may not be empty at the end, so that the execution doesnâ€™t stop at an input statement at the end.
* Itâ€™s *unclean*: the `main` code becomes less clean, and with a `system` command also needlessly non-portable.
* Itâ€™s *premature*: at the point where the program stops (if it stops), static cleanup has not yet been performed, so any effects from that canâ€™t be observed.
* Itâ€™s *annoying*: when the program is run from a command interpreter the user needlessly has to interact with it to terminate it at the end.
* Itâ€™s *obstructive*: when the program is used in a script/batch file, including for testing such as measuring the run time, one must work around the stopping behavior.

With Kickstart you can largely avoid the above five problems by instead **force-including** the **`<kickstart/Â¤-keep-console.hpp>`** header. â€œForce-includingâ€ means that you use a compiler option to include it, instead of an `#include` directive in the code. With Visual C++ itâ€™s option `/FI`, and with g++ itâ€™s `-include`.

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl hello-world.cpp /FI"kickstart/Â¤-keep-console.hpp" /Fe"hello"***  
> hello-world.cpp
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***hello***  
> Hello, world!

Uhm, hey, itâ€™s just the same as before?!?

Yes, thatâ€™s by design. The behavior when the program is run from a command interpreter is exactly the same as before; no change. That supports the last two bullet points above, to not be annoying or obstructive.

But watch what happens when itâ€™s run by double-clicking the executable in Windows Explorer:

![](images/hello-world.shadowed.png "Paused â€œHello, world!â€ console window.")

Yay!

Notes:

1. Thereâ€™s no guarantee that all relevant static cleanup has been performed at this point, because the stopping is done by the destructor of a global object. For example, an earlier opened file that has not been explicitly closed, may still be open so that it canâ€™t yet be deleted. But all static cleanup performed by object destructors will in practice have been performed.

2. When you just want to keep the console window when you run your program from an IDE such as Visual Studio, then itâ€™s much simpler to use the IDEâ€™s functionality. For example, in Visual Studio run the program via keypress **Ctrl** + **F5**, and for example, in Code::Blocks run the program via keypress **F9**. However, the `<kickstart/Â¤-keep-console.hpp>` header can still be useful *for debugging* in an IDE, because typically the debugger does not provide a â€œkeep console openâ€ stop at the end.

3. As a workaround for a Code::Blocks bug the library offers a header wrapper **<kickstart/tool-specific/code-blocks/keep-console.hpp>** that one can use in Code::Blocks. The bug: in the authorâ€™s testing the Code::Blocks IDE in Ubuntu (and maybe everywhere) just silently *skipped* invoking the compiler, and erroneously reported successful compilation, when the forced include filename had a â€œÂ¤â€ in front. Ugh!

---

The Unix version of `<kickstart/Â¤-keep-console.hpp>` *always* stops at the end, even when the program is run from a command interpreter:

> [~/dev/libraries/kickstart-1/documentation/tutorial/examples]  
> $ ***OPT="-std=c++17 -pedantic-errors -Wall"***  
> 
> [~/dev/libraries/kickstart-1/documentation/tutorial/examples]  
> $ ***g++ $OPT hello-world.cpp -include "kickstart/Â¤-keep-console.hpp" -o hello***  
> 
> [~/dev/libraries/kickstart-1/documentation/tutorial/examples]  
> $ ***./hello***  
> Hello, world!  
> â–· Press Enter to continue: 

This rather primitive but at least reliable behavior is because any practical way to have double-clicking run a program in a terminal window, in Ubuntu, probably involves running the program via a shell such as Bash, so that in general there will be at least one and maybe more other processes attached to the console.

E.g., when the author explored double-clicking of modern g++-produced executables in the Nautilus file explorer in Gnome in Ubuntu, it turned out that â€œrun a modern executableâ€ functionality was not present by default (!), and *creating that functionality* involved some installations (which may or may not have been necessary) plus adding a file â€œ[/usr/local/share/applications/run-in-terminal.desktop](examples/run-in-terminal/ubuntu/run-in-terminal.desktop)â€ that specified an â€œOpen withâ€ item that invoked a file â€œ[/usr/local/bin/run-in-terminal.sh](examples/run-in-terminal/ubuntu/run-in-terminal.sh)â€ that, due to apparent bugs in `gnome-terminal`, dynamically created a â€œ/tmp/â€ shell script to run the program, which script it in turn passed as â€œ`--`â€-command to `gnome-terminal`&hellip;

But the Ubuntu/Unix environment also enabled a nice little feature, namely that the â€œPress Enter to continue:â€ text is presented in subdued gray color:

![](images/run-in-ubuntu/hello-world.stopped.png "Paused â€œHello, world!â€ console window.")









## 3. Text i/o.

### 3.1. Output of non-English letters like Norwegian Ã†Ã˜Ã….

Pretend that youâ€™re a Norwegian student named BjÃ¸rn HÃ¥vard SÃ¦ther. You want to write a portable C++ program that displays your name, whether you compile and run it in Linux or in Windows. Thatâ€™s easy with Kickstart:

*File ([bhs.cpp](examples/bhs.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    out << "Dear world, BjÃ¸rn HÃ¥vard SÃ¦ther says hello!" << endl;
}
~~~

Output:

> Dear world, BjÃ¸rn HÃ¥vard SÃ¦ther says hello!

---

Hereâ€™s code that ideally should do the same, but using the C++ standard library directly:

*File ([bhs.stdlib.cpp](examples/bhs.stdlib.cpp)):*
~~~cpp
#include <iostream>
using namespace std;

auto main() -> int
{
    cout << "Dear world, BjÃ¸rn HÃ¥vard SÃ¦ther says hello!" << endl;
}
~~~

Output in a Windows console, using the defaults:

> Dear world, Bjâ”œÂ©rn Hâ”œÃ‘vard Sâ”œÂªther says hello!

The gobbledygook appears because the console expects a different text encoding than UTF-8, and because *the Visual C++ standard library implementation does not address that issue*.

This is so also with the other common Windows compilers. The Windows C++ standard library implementations could have done the same as Kickstart, with Just Works&trade; behavior, but they donâ€™t. Presumably that common misbehavior is due to common *reuse* of a core of flawed functionality in Microsoftâ€™s C runtime library.
