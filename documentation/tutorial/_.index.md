# **Kickstart library tutorial**

Kickstart is intended to ease the way for beginners in C++, and helps to shorten example code for those who help others on the net.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [**1. Installation & compiler requirements.**](#1-installation--compiler-requirements)
- [**2. ‚ÄúHello, world!‚Äù ‚Äî or, keep that console window open, please.**](#2-hello-world--or-keep-that-console-window-open-please)
  - [**2.1. Basic Kickstart output.**](#21-basic-kickstart-output)
  - [**2.2. Prevent console window closing in Windows, in a good way.**](#22-prevent-console-window-closing-in-windows-in-a-good-way)
  - [**2.3. Prevent console window closing in Unix.**](#23-prevent-console-window-closing-in-unix)
- [**3. Text i/o.**](#3-text-io)
  - [**3.1. Output of text with non-English letters like Norwegian √Ü√ò√Ö.**](#31-output-of-text-with-non-english-letters-like-norwegian-%C3%A6%C3%B8%C3%A5)
  - [**3.2. Input of text with non-English letters like Norwegian √Ü√ò√Ö.**](#32-input-of-text-with-non-english-letters-like-norwegian-%C3%A6%C3%B8%C3%A5)
  - [3.3 **Input of numbers.**](#33-input-of-numbers)
  - [**3.4 Tabular output of numbers.**](#34-tabular-output-of-numbers)
  - [**3.5 Formatting of floating point values.**](#35-formatting-of-floating-point-values)
- [**4. Command line arguments.**](#4-command-line-arguments)
  - [**4.1 The `process::the_commandline()` function.**](#41-the-processthe_commandline-function)
  - [**4.2 Using the `main` arguments as a default in non-Windows systems.**](#42-using-the-main-arguments-as-a-default-in-non-windows-systems)
  - [**4.3 Command line options parsing via a 3 ≥·µà party library.**](#43-command-line-options-parsing-via-a-3%CA%B3%E1%B5%88-party-library)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->


## **1. Installation & compiler requirements.**

All you need to do is download, copy and rename, so that the compiler finds the `<kickstart/`&hellip;`>` headers. There is no need to compile the library on its own. All the library code is in headers that you just `#include`.

Installation is described in more detail in [a separate document](../../source/examples/hello-world.md).

Then after installation, to use Kickstart you need to use a compiler option that specifies at least ***C++17***. Also, the Kickstart i/o functionality requires that C++ strings are UTF-8 encoded, which they‚Äôre not by default with the 2019 version of Microsoft‚Äôs Visual C++ compiler, and the Kickstart code uses the alternate keywords `and`, `or` and `not`, which again are a problem with Visual C++. Recommended options to guide the compilers:

| *Compiler:* | *Recommended core options:* |
|:-|:-|
| g++ &amp; clang | `-std=c++17` `-pedantic-errors` `-Wall` |
| Visual C++ | `/nologo` `/utf-8` `/EHsc` `/GR` `/permissive-` `/FI"iso646.h"` `/std:c++17` `/Zc:__cplusplus` `/W4` `/wd4459` `/D` `_CRT_SECURE_NO_WARNINGS` `/D` `_STL_SECURE_NO_WARNINGS` |

Happily, for Visual C++ options can be specified in environment variable `CL`, which is used automatically.


## **2. ‚ÄúHello, world!‚Äù ‚Äî or, keep that console window open, please.**

### **2.1. Basic Kickstart output.**

Here‚Äôs the classic ‚ÄúHello, world!‚Äù program expressed with Kickstart console output:

*File ([hello-world.cpp](examples/hello-world.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    out << "Hello, world!" << endl;
}
~~~

`out`, `<<` and `endl` are names provided by the Kickstart library in namespace `kickstart::all`. When the output goes to a Windows console then it‚Äôs sent there via the UTF-16 based Windows API function `WriteConsoleW` so that e.g. non-English letters are treated correctly. In all other cases the `out` output is delegated to C‚Äôs `fwrite`.

Result in an ordinary Windows console window:

> C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl hello-world.cpp /Fe"hello"***  
> hello-world.cpp
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***hello***  
> Hello, world!

Works! üòÉ

The **`cl`** command invokes the Visual C++ 2019 compiler, and option `/Fe"hello"` tells it to produce an executable named `hello.exe`, which can then be invoked with command `hello`.

### **2.2. Prevent console window closing in Windows, in a good way.**

Beginners that are learning in Windows, typically insert a ‚Äústop here‚Äù statement at the end of each program. This keeps the Windows console window open when the program has finished so that the program‚Äôs output can be viewed. The stopping statement can be a portable input statement, or it can be e.g. a Windows-specific `system("pause")`, but anyway it‚Äôs problematic:

* It‚Äôs *unreliable*: in a typical beginner's program the input buffer may not be empty at the end, so that the execution doesn‚Äôt stop at an input statement at the end.
* It‚Äôs *unclean*: the `main` code becomes less clean, and with a `system` command also needlessly non-portable.
* It‚Äôs *premature*: at the point where the program stops (if it stops), static cleanup has not yet been performed, so any effects from that can‚Äôt be observed.
* It‚Äôs *annoying*: when the program is run from a command interpreter the user needlessly has to interact with it to terminate it at the end.
* It‚Äôs *obstructive*: when the program is used in a script/batch file, including for testing such as measuring the run time, one must work around the stopping behavior.

With Kickstart you can largely avoid the above five problems by instead **force-including** the **`<kickstart/~keep-console.hpp>`** header. ‚ÄúForce-including‚Äù means that you use a compiler option to include it, instead of an `#include` directive in the code. With Visual C++ it‚Äôs option `/FI`, and with g++ it‚Äôs `-include`.

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***cl hello-world.cpp /FI"kickstart/~keep-console.hpp" /Fe"hello"***  
> hello-world.cpp
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***hello***  
> Hello, world!

Uhm, hey, it‚Äôs just the same as before?!?

Yes, that‚Äôs by design. The behavior when the program is run from a command interpreter is exactly the same as before; no change. That supports the last two bullet points above, to not be annoying or obstructive.

But watch what happens when it‚Äôs run by double-clicking the executable in Windows Explorer:

![](images/hello-world.shadowed.png "Paused ‚ÄúHello, world!‚Äù console window.")

Notes:

1. All static cleanup performed by object destructors will in practice have been performed, but there‚Äôs no guarantee that all relevant static cleanup has been performed at this point.

2. When you just want to keep the console window when you run your program (without debugging) from an IDE such as Visual Studio, then it‚Äôs much simpler to use the IDE‚Äôs functionality. For example, in Visual Studio run the program via keypress **Ctrl** + **F5**. And, for example, in Code::Blocks run the program via keypress **F9**.


### **2.3. Prevent console window closing in Unix.**

The Unix version of `<kickstart/~keep-console.hpp>` always stops at the end, even when the program is run from a command interpreter:

> [~/dev/libraries/kickstart-1/documentation/tutorial/examples]  
> $ ***OPT="-std=c++17 -pedantic-errors -Wall"***  
> 
> [~/dev/libraries/kickstart-1/documentation/tutorial/examples]  
> $ ***g++ $OPT hello-world.cpp -include "kickstart/~keep-console.hpp" -o hello***  
> 
> [~/dev/libraries/kickstart-1/documentation/tutorial/examples]  
> $ ***./hello***  
> Hello, world!  
> ‚ñ∑ Press Enter to continue: 

This rather primitive but at least reliable behavior is because any practical way to have double-clicking run a program in a terminal window, in Ubuntu, [probably involves running the program via a shell such as Bash](detail_-_running_your_executable_by_double-clicking_in_Ubuntu.md), so that in general there will be at least one and maybe more other processes attached to the console.

But the Ubuntu/Unix environment enabled a nice little feature, namely that the ‚ÄúPress Enter to continue:‚Äù text is presented in subdued gray color:

![](images/run-in-ubuntu/hello-world.stopped.png "Paused ‚ÄúHello, world!‚Äù console window.")


## **3. Text i/o.**

### **3.1. Output of text with non-English letters like Norwegian √Ü√ò√Ö.**

Pretend that you‚Äôre a Norwegian student named Bj√∏rn H√•vard S√¶ther. You want to write a portable C++ program that displays your name, whether you compile and run it in Linux or in Windows. That‚Äôs easy with Kickstart:

*File ([bhs.cpp](examples/bhs.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    out << "Dear world, Bj√∏rn H√•vard S√¶ther says hello!" << endl;
}
~~~

Output:

> Dear world, Bj√∏rn H√•vard S√¶ther says hello!

To people unfamiliar with Windows programming functionality that *outputs the specified text* may not seem so impressive, but code that directly uses `printf` or the `std::cout` stream in Windows will instead by default produce [gobbledygook like ‚ÄúDear world, Bj‚îú¬©rn H‚îú√ëvard S‚îú¬™ther says hello!‚Äù](detail_-_output_of_international_text_in_Windows.md).

Note: To display emojis like üòÉ correctly in Windows you will generally have to use a terminal emulator like [**Microsoft Terminal**](https://github.com/microsoft/terminal). Windows console windows only support a very limited set of general symbols, essentially those from the original IBM PC‚Äôs character set, like ‚ò∫. Kickstart defines [names for these symbols](../../source/library/console/portable_dingbats.hpp#L36) if you want to use them, e.g. `kickstart::portable_dingbats::smiley`.

### **3.2. Input of text with non-English letters like Norwegian √Ü√ò√Ö.**

Kickstart only offers input of complete lines of text, at the highest level via a function **`input()`** ‚Üí `string`.

With the function it‚Äôs easier to avoid non-`const` variables, and with the restriction to whole lines it‚Äôs easier to avoid the common beginner‚Äôs problem that an input buffer contains unconsumed text from some earlier input operation.

Example:


*File ([personalized-kickstart-greeting.cpp](examples/personalized-kickstart-greeting.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    const string name = input( "Hi, what‚Äôs your name? " );
    out << "Welcome to the Kickstart experience, " << name << "!" << endl;
}
~~~

Typical result:

> Hi, what‚Äôs your name? ***Bj√∏rn H√•vard S√¶ther***  
> Welcome to the Kickstart experience, Bj√∏rn H√•vard S√¶ther!

The above result was obtained in a classic Windows console, showing that Kickstart input deals correctly with non-English characters in this environment.

The code also shows that the `kickstart::all` namespace brings in some select often used identifiers from the standard library; here `string` is `std::string`. The `endl` identifier is however not the one from the standard library. That can possibly be worth being aware of.

---

Here‚Äôs code that ideally should do the same, but using the C++ standard library directly:

*File ([personalized-kickstart-greeting.stdlib.cpp](examples/personalized-kickstart-greeting.stdlib.cpp)):*
~~~cpp
#include <iostream>
#include <string>
using namespace std;

auto fail() -> bool { throw "Gah!"; }

auto main() -> int
{
    string name;
    cout << "Hi, what‚Äôs your name? ";
    getline( cin, name ) or fail();
    cout << "Welcome to the C++ standard library experience, " << name << "!" << endl;
}
~~~

Typical result in a default Windows classic console on the author‚Äôs system, with a `chcp` command reporting the active codepage:

> Active code page: 850  
> Hi, what√î√á√ñs your name? ***Bj√∏rn H√•vard S√¶ther***  
> Welcome to the C++ standard library experience, Bj√∏rn H√•vard S√¶ther!

Uhuh. Some trouble with the UTF-8 encoded round apostrophe, so let‚Äôs switch to codepage 65001:

> Active code page: 65001  
> Hi, what‚Äôs your name? ***Bj√∏rn H√•vard S√¶ther***  
> Welcome to the C++ standard library experience, Bj rn H vard S ther!

Now the round apostrophe is correctly presented. Codepage 65001 works for standard library UTF-8 *output*. But the non-ASCII characters in the name ‚ÄúBj√∏rn H√•vard S√¶ther‚Äù are not handled correctly: they end up being presented as spaces! Actually the Windows API level‚Äôs `ReadFile` function produces a string with zero values for these input characters, and the current Windows implementations of the C++ standard library all blithely assume that `ReadFile` works, so codepage 65001 decidedly does not work for standard library *input*.

And as of early 2021 this happens with C++ standard library input whether one uses a classic console or Microsoft Terminal.

---

By default `std::cin` input operations just fail silently, which can wreak all kinds of serious havoc: a crash, a hang, or a plausible but incorrect result that is believed, and incurs devastating costs for a company&hellip;

In contrast, when Kickstart‚Äôs `input()` detects End Of File&trade; ‚Äî about the only way that input of a text line can fail ‚Äî it throws an exception.

To ensure that such exceptions are reported to you if they escape out of your main code, you can replace your `main` function with a function named e.g. `cppmain`, and provide a one-liner little micro-`main` that calls that function via Kickstart‚Äôs **`with_exceptions_displayed`**:

*File ([personalized-kickstart-greeting.with-exceptions-reported.cpp](examples/personalized-kickstart-greeting.with-exceptions-reported.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

void cppmain()
{
    const string name = input( "Hi, what‚Äôs your name? " );
    out << "Welcome to the Kickstart experience, " << name << "!" << endl;
}

auto main() -> int { return with_exceptions_displayed( cppmain ); }
~~~

For example, in a Windows console window, when you respond to this program‚Äôs prompt

> Hi, what‚Äôs your name?

&hellip; by pressing **Ctrl** **Z** and then Enter, you get

> Hi, what‚Äôs your name? ***^Z***  
> !input_from - At end of file.

Here `input_from` is the function that `input` calls and that detected EOF.

`with_exceptions_displayed` does not propagate the exception (if any), but just returns standard `EXIT_FAILURE` if there was an exception, and otherwise it returns standard `EXIT_SUCCESS`.

### 3.3 **Input of numbers.**

Unlike the standard library Kickstart has no dedicated number input operation. Instead you just input a line of text with `input()`, as usual. You can then attempt to convert that line to a number, e.g. with **`to_<int>`** or `to_<double>`:

*File ([personalized-kickstart-greeting.with-age.cpp](examples/personalized-kickstart-greeting.with-age.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

void cppmain()
{
    const string name = input( "Hi, what‚Äôs your name? " );
    const int age = to_<int>( input( "And please, your age (in years)? " ) );

    out << "Welcome to the Kickstart experience, "
        << age << " year" << (age == 1? "": "s")
        << " old "<< name << "!" << endl;
}

auto main() -> int { return with_exceptions_displayed( cppmain ); }
~~~

Typical result:

> Hi, what‚Äôs your name? ***Alf***  
> And please, your age (in years)? ***58***  
> Welcome to the Kickstart experience, 58 years old Alf!

Note: as of early 2021 `to_` only supports types `int` and `double`.

---

If the string argument is an invalid value specification for the result type, then `to_` throws an exception with exception text depending on the kind of spec error:

> Hi, what‚Äôs your name? ***Alf***  
> And please, your age (in years)? ***58.3***  
!to_ - Decimals were specified for an integer value.

The exception text is always in English because it‚Äôs a message intended for programmers.

Different types of exception are thrown for different conditions, so you can differentiate between different failures. E.g. for the purpose of providing explanatory messages to the user. See the Kickstart source code for details.

---

Unlike e.g. `std::stoi`, Kickstart‚Äôs `to_<int>` will accept a specification like `1e6`, meaning one million:

> Hi, what‚Äôs your name? ***Alf***  
> And please, your age (in years)? ***1e6***  
Welcome to the Kickstart experience, 1000000 years old Alf!

It will also accept an integer value specified with decimals if they‚Äôre all zero, e.g.

> Hi, what‚Äôs your name? ***Alf***  
> And please, your age (in years)? ***58.000***  
> Welcome to the Kickstart experience, 58 years old Alf!

However, this is accomplished internally by trying to interpret the string as a `double` value specification and checking whether that yields an exact integer. Therefore `to_<int>` may accept a smaller range of values than supported by `int`. In practice this can happen with a compiler and platform where both `int` and `double` are 64-bit, when the specified value is ‚â• 2‚Åµ¬≥ (a rather large number!), but in Windows `int` is 32-bit so that range limit is hit first.

### **3.4 Tabular output of numbers.**

The Kickstart `out` stream is  a *very* shallow wrapper over a function called `output`. It just passes the `<<` arguments to that function. There is nothing like the standard library iostreams formatting, nothing like e.g. `std::setw`.

Instead, where you want to e.g. place some ASCII output right-adjusted in a field *n* characters wide, you just use the [**`ascii::at_right_in`**](../../source/library/core/text-encoding-ascii/string-util.hpp#L81) function. The ‚ÄúASCII‚Äù is not really a restriction to ASCII characters, but just that each `char` value in the string should produce one character cell in the console. However, with UTF-8 encoding all non-ASCII characters use two or more `char` values. There‚Äôs also a corresponding `at_left_in`, of course. These functions take the field width *n* as an `int` 1À¢·µó parameter, and the something to be displayed as a `std::string_view` 2‚Åø·µà parameter.

 You can pass a `std::string` directly as argument to second parameter. And one way to get a string from e.g. an `int` value, is to use the Kickstart `str` function (or you could use e.g. `std::to_string`). It can go like this:

*File ([multiplication-table.cpp](examples/multiplication-table.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    const int n = 12;
    for( int row = 1; row <= n; ++row ) {
        for( int col = 1; col <= n; ++col ) {
            out << ascii::at_right_in( 4, str( row*col ) );
        }
        out << endl;
    }
}
~~~

Result:

~~~txt
   1   2   3   4   5   6   7   8   9  10  11  12
   2   4   6   8  10  12  14  16  18  20  22  24
   3   6   9  12  15  18  21  24  27  30  33  36
   4   8  12  16  20  24  28  32  36  40  44  48
   5  10  15  20  25  30  35  40  45  50  55  60
   6  12  18  24  30  36  42  48  54  60  66  72
   7  14  21  28  35  42  49  56  63  70  77  84
   8  16  24  32  40  48  56  64  72  80  88  96
   9  18  27  36  45  54  63  72  81  90  99 108
  10  20  30  40  50  60  70  80  90 100 110 120
  11  22  33  44  55  66  77  88  99 110 121 132
  12  24  36  48  60  72  84  96 108 120 132 144
  ~~~

Using a fixed width font preformatted text block for the above result display in order to get the console window text formatting correct.

### **3.5 Formatting of floating point values.**

The `out <<` operation converts a floating point value to text via `str`. This default conversion is handy but gives you no control over the number of presented decimals. To control that you can use the **`to_fixed`** and **`to_scientific`** functions:

*File ([floating-point-formatting.cpp](examples/floating-point-formatting.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;
using ascii::at_right_in;

auto main() -> int
{
    double x = math::pi;
    for( int i = 1; i <= 5; ++i, x *= 1000 ) {
        out << at_right_in( 20, str( x ) )
            << at_right_in( 20, to_fixed( x, 4 ) )
            << at_right_in( 20, to_scientific( x, 4 ) )
            << endl;
    }
}
~~~

Result:

~~~txt
             3.14159              3.1416          3.1416e+00
             3141.59           3141.5927          3.1416e+03
         3.14159e+06        3141592.6536          3.1416e+06
         3.14159e+09     3141592653.5898          3.1416e+09
         3.14159e+12  3141592653589.7930          3.1416e+12
~~~

Here [`math::pi`](https://github.com/alf-p-steinbach/kickstart/blob/4c82e9565471102008732a80ec93ba85f5ec5aee/source/library/core/language/stdlib-extensions/math.hpp#L42) is a constant defined by Kickstart. C++20 defines [`std::numbers::pi`](https://en.cppreference.com/w/cpp/numeric/constants), but for C++17 and earlier one had to make do with the Posix standard‚Äôs macro [`M_PI`](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/math.h.html). Usually one would just define the œÄ constant in DIY fashion.

Note: `double` represents a limited number of digits of a value. When you try to present more digits you‚Äôll generally get arbitrary nonsense. Thus, the last fixed point value `3141592653589.7930` is not entirely correct in the last digit; the mathematically correct rounded value would be `3141592653589.7932` (the digit sequence continues `3846`‚Ä¶).

## **4. Command line arguments.**

### **4.1 The `process::the_commandline()` function.**
The main Kickstart way to access command line arguments is via the **`process::the_commandline()`** function, which returns a reference to a static object:

*File ([command-line-args.cpp](examples/command-line-args.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

auto main() -> int
{
    const auto& cmd = process::the_commandline();

    out << cmd.verb() << endl;
    for( const string& arg: cmd.args() ) {
        out << arg << endl;
    }
}
~~~

`process` is a namespace for process related functionality. I.e. it‚Äôs not a verb, it doesn‚Äôt indicate that `process::the_commandline()` does things with the command line, such as parsing it. Although it actually does that in Windows; hm.

Anyway, result in a classic Windows console, with a `chcp` command reporting the active codepage at the start:

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***chcp & command-line-args.exe bl√•b√¶rsyltet√∏y "(blueberry jam)" could be used in a œÄ***  
> Active code page: 850  
> command-line-args.exe  
> bl√•b√¶rsyltet√∏y  
> (blueberry jam)  
> could  
> be  
> used  
> in  
> a  
> œÄ

Works! üòÉ

Except that

* *as of early 2021 ‚Äúget commandline from OS‚Äù is only implemented for Windows and Linux.*

In particular there‚Äôs as yet no implementation for the Mac. So what to do on the Mac?


### **4.2 Using the `main` arguments as a default in non-Windows systems.**

In Unix environments, which includes the Mac, as of 2021 the `main` arguments can in practice be relied on to be UTF-8 encoded.

You can therefore pass these ‚Äúraw‚Äù command line arguments to the Kickstart `with_exceptions_displayed` function, which by default will do one of two things:

* on a Windows system the passed arguments are ignored (because they likely contain distorted information) and the command line is retrieved from the OS, while

* on other systems the passed command line arguments are used to initialize the command line singleton, presently just assuming that they‚Äôre valid UTF-8.

It can go like this:

*File ([command-line-args.portable.cpp](examples/command-line-args.portable.cpp)):*
~~~cpp
#include <kickstart/all.hpp>
using namespace kickstart::all;

void cppmain()
{
    const auto& cmd = process::the_commandline();

    out << cmd.verb() << endl;
    for( const string& arg: cmd.args() ) {
        out << arg << endl;
    }
}

auto main( int n_cmd_parts, char** cmd_parts )
    -> int
{ return with_exceptions_displayed( cppmain, n_cmd_parts, cmd_parts ); }
~~~

Result in a classic Windows console, where the passed arguments are ignored:

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***command-line-args.portable.exe Maybe, bl√•b√¶rsyltet√∏y in a œÄ?***  
> command-line-args.portable.exe  
> Maybe,  
> bl√•b√¶rsyltet√∏y  
> in  
> a  
> œÄ?

Result in WSL Ubuntu, where now the passed arguments are used:

> [/mnt/e/root/c/my/dev/libraries/kickstart-1/documentation/tutorial/examples]  
> \$ **./command-line-args.portable Maybe, bl√•b√¶rsyltet√∏y in a œÄ?**  
> ./command-line-args.portable  
> Maybe,  
> bl√•b√¶rsyltet√∏y  
> in  
> a  
> œÄ?  


### **4.3 Command line options parsing via a 3 ≥·µà party library.**

In Unix environments command line options parsing is partially standardized, at first via Posix‚Äô C [`getopt`](https://man7.org/linux/man-pages/man3/getopt.3.html) function, which supports single character options that start with a single dash ‚Äú`-`‚Äù.  `getopt` was succeeded by `getopt_long` that supports ‚Äúlong‚Äù (i.e. named) options that start with two dashes ‚Äú`--`‚Äù, and that in turn was succeeded by the [`popt`](https://linux.die.net/man/3/popt) library, which does not use global variables and is more flexible also in other ways. Options parsing based on this *de facto* standard for command line syntax is also available in other languages, e.g. [in Python](https://docs.python.org/3/library/getopt.html).

Sadly as of early 2021 there seems to be no high-quality readily usable free such options parsing library for C++. For example, [Boost Program Options](https://theboostcpplibraries.com/boost.program_options) requires separate compilation, which is a pain with Boost. However, there is a free header only library called [**‚Äúcxxopts‚Äù**](https://github.com/jarro2783/cxxopts) which, although lacking especially in `const` support, Does The Job&trade; for C++.

The following minimal ‚Äúcxxopts‚Äù wrapper class

1. supports `const`,
2. replaces dynamic options specifications (one does not really want available command line options to depend on something determined at run time) with constructor arguments, and
3. adapts the `parse` function to Kickstart.

*File ([wrapped-cxxoptions.hpp](examples/wrapped-cxxoptions.hpp)):*
~~~cpp
#pragma once
#include <kickstart/all.hpp>    // <url: https://github.com/alf-p-steinbach/kickstart>
#include <cxxopts.hpp>          // <url: https://github.com/jarro2783/cxxopts>

#include <initializer_list>
#include <optional>
#include <memory>
#include <string>
#include <type_traits>

namespace my {
    namespace ks = kickstart::all;
    using   ks::Array_span_, ks::C_str, ks::str, ks::int_size, ks::begin_ptr_of;
    using   std::initializer_list,      // From <initializer_list>.
            std::move,                  // From <optional>.
            std::shared_ptr,            // From <memory>.
            std::string,                // From <string>
            std::is_same_v;             // From <type_traits>.

    class Options
    {
        mutable cxxopts::Options    m_cxxopts;

        using V = cxxopts::Value;

        template< class Type >
        static auto value() -> shared_ptr<V> { return cxxopts::value<Type>(); }

    public:
        struct Spec
        {
            string                      m_options;
            string                      m_description;
            std::shared_ptr<const V>    m_value;
            string                      m_arg_help;
        };

        Options(
            string                          appname,
            string                          description,
            const initializer_list<Spec>    specs = {}
            ):
            m_cxxopts( appname, description )
        {
            for( const auto spec: specs ) {
                m_cxxopts.add_options()(
                    spec.m_options,
                    spec.m_description,
                    (spec.m_value? spec.m_value : ::cxxopts::value<bool>()),
                    spec.m_arg_help
                    );
            }
        }
        
        template< class Type >
        static auto spec_for( const Type v )
            -> string
        {
            using std::is_same_v;
            if constexpr( is_same_v<Type, bool> ) {
                return (v? "true" : "false");
            } else {    // Using `else` suppresses an MSVC ‚Äúunreachable code‚Äù warning.
                return str( v );
            }
        }

        // Just specifies the kind of option.
        template< class Type >
        static auto kind()
            -> shared_ptr<V>
        { return value<Type>(); }

        // Specifies the result when an option is not present in the command line.
        template< class Type >
        static auto no_option_default( const Type v )
            -> shared_ptr<V>
        { return value<Type>()->default_value( spec_for( v ) ); }

        // Specifies the result when an option is present but sans value spec.
        template< class Type >
        static auto no_value_default( const Type v )
            -> shared_ptr<V>
        { return value<Type>()->implicit_value( spec_for( v ) ); }

        auto parse( const Array_span_<const C_str> parts ) const
            -> cxxopts::ParseResult
        { return m_cxxopts.parse( int_size( parts ), begin_ptr_of( parts ) ); }
        
        auto help_text() const
            -> string
        { return m_cxxopts.help(); }
    };
}  // namespace my
~~~

  The `Array_span_<const C_str>` parameter type for `parse` is directly the type produced by the [**`.c_strings()`**](../../source/library/process/Commandline.hpp#L169) member function of the Kickstart command line singleton, which provides the mentioned Kickstart adaption, but it‚Äôs also easy to form an `Array_span_` directly out of e.g. the `main` arguments. Kickstart‚Äôs [**`Array_span_`**](../../source/library/core/language/collection-util.hpp#L68) corresponds to a pared down C++20 [`std::span`](https://en.cppreference.com/w/cpp/container/span) with dynamic extent; just a pair of pointers into an array. The [**`C_str`**](../../source/library/core/language/type-aliases.hpp#L37) type is technically even simpler, just an alias for `const char*`, but the name implies a zero-terminated string.

[**`int_size`**](../../source/library/core/language/collection-util.hpp#L43) is a general convenience function for collection classes, which avoids a `static_cast<int>` of the size, and [**`begin_ptr_of`**](../../source/library/core/language/collection-util.hpp#L48) is likewise just a convenience function, that returns a pointer to the first item.

Example usage:

*File ([program-options.cpp](examples/program-options.cpp)):*
~~~cpp
// Based on the example at <url: https://github.com/jarro2783/cxxopts#example>.
#ifdef __GNUC__
#   pragma GCC diagnostic ignored "-Wmissing-field-initializers"    // Sillywarning.
#endif

#include "wrapped-cxxoptions.hpp"       // my::Options
using my::Options;

#include <kickstart/all.hpp>
using namespace kickstart::all;

void cppmain()
{
    const auto& cmd = process::the_commandline();
    const auto options = Options( cmd.verb(), "A cxxopts command line options example.",
    {
        { "b,bar",      "Param bar",        Options::kind<string>() },
        { "d,debug",    "Enable debugging", Options::no_option_default( true ) },
        { "f,foo",      "Param foo",        Options::no_option_default( 10 ) },
        { "h,help",     "Print usage" }
    } );

    const auto parse_result = options.parse( cmd.c_strings() );
    if( cmd.args().size() == 0 or parse_result.count( "help" ) > 0 ) {
        out << options.help_text() << endl;
    } else {
        const auto& r = parse_result;

        const string    bar     = (r.count( "bar" ) > 0? r["bar"].as<string>() : "");
        const bool      debug   = r["debug"].as<bool>();
        const int       foo     = r["foo"].as<int>();

        out << "bar = ‚Äú" << bar << "‚Äù"
            << ", debug = " << Options::spec_for( debug )
            << ", foo = " << foo
            << "." << endl;
        const vector<string>& rest = r.unmatched();
        if( rest.empty() ) {
            out << "Everything in the command line was matched as options." << endl;
        } else {
            out << "Unmatched command line parts:" << endl;
            for( const string& s: rest ) {
                out << "‚Ä¢ ‚Äú" << s << "‚Äù." << endl;
            }
        }
    }
}

auto main( int n_cmd_parts, char** cmd_parts )
    -> int
{ return with_exceptions_displayed( cppmain, n_cmd_parts, cmd_parts ); }
~~~

Some results in a classic Windows console:

> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***b***  
> A cxxopts command line options example.  
> Usage:  
> &nbsp;&nbsp;&nbsp;&nbsp;b [OPTION...]  
> 
> &nbsp;&nbsp;&nbsp;&nbsp;-b, --bar arg  Param bar  
> &nbsp;&nbsp;&nbsp;&nbsp;-d, --debug    Enable debugging (default: true)  
> &nbsp;&nbsp;&nbsp;&nbsp;-f, --foo arg  Param foo (default: 10)  
> &nbsp;&nbsp;&nbsp;&nbsp;-h, --help     Print usage  
> 
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***b --bar tender or --foo fighter or what?***  
> !Argument 'fighter' failed to parse  
> 
> [C:\my\dev\libraries\kickstart-1\documentation\tutorial\examples]  
> \> ***b --bar tender or --foo 42 or what?***  
> bar = ‚Äútender‚Äù, debug = true, foo = 42.  
> Unmatched command line parts:  
> ‚Ä¢ ‚Äúor‚Äù.  
> ‚Ä¢ ‚Äúor‚Äù.  
> ‚Ä¢ ‚Äúwhat?‚Äù.

The ‚Äú*!Argument 'fighter' failed to parse*‚Äù diagnostic is displayed by Kickstart‚Äôs `with_exceptions_displayed`, as the text of an exception produced by `cxxopts::Options::parse`.

I.e. you need exception handling in order to use ‚Äúcxxopts‚Äù and many other C++ libraries, and `with_exceptions_displayed` provides the minimum for a console program.
